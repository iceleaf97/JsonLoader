<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>connectome</title>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/OBJLoader.js"></script>
</head>
<body>

<script type="x-shader/x-vertex" id="vertexshader">

    attribute float alpha;

    varying float vAlpha;

    void main() {

        vAlpha = alpha;

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        gl_PointSize = 4.0;

        gl_Position = projectionMatrix * mvPosition;

    }

</script>

<script type="x-shader/x-fragment" id="fragmentshader">

    uniform vec3 color;

    varying float vAlpha;

    void main() {

        gl_FragColor = vec4( color, vAlpha );

    }

</script>
<script type="x-shader/x-vertex" id="vertexshader2">

    attribute float alpha;

    varying float vAlpha;

    void main() {

        vAlpha = alpha;

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        gl_PointSize = 10.0;

        gl_Position = projectionMatrix * mvPosition;

    }

</script>

<script type="x-shader/x-fragment" id="fragmentshader2">

    uniform vec3 color2;

    varying float vAlpha;

    void main() {

        gl_FragColor = vec4( color2, vAlpha );

    }

</script>
<script>
    // PointCloud with Custom, Dynamic Attribute

    var renderer, scene, camera, cloud, uniforms,mesh,control, ballmesh, ballPoint;



    init();
    animate();

    function init() {

        // renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        // scene
        scene = new THREE.Scene();

        //camera
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set(0,0,400);
        control = new THREE.OrbitControls(camera, renderer.domElement);
        control.target = new THREE.Vector3(0,0,0);


        // point cloud geometry



        var geometry = new THREE.SphereBufferGeometry( 100, 20, 20 );



        var jsonLoader = new THREE.JSONLoader();
        jsonLoader.load('models/ball.json', addJsonToScn);
        function addJsonToScn(geometry) {
            var ball = new THREE.BufferGeometry().fromGeometry(geometry);
           // console.log(ball.attributes.position.count);
            var numBallVert = ball.attributes.position.count;
            var alphas = new Float32Array( numBallVert * 1 );
            //console.log(alphas);
            for(var i=0; i<numBallVert;i++){
                alphas[i]= 1;
            }
            ball.addAttribute('alpha',new THREE.BufferAttribute(alphas,1));

            uniforms2 = {
                color2: { type:"c", value:new THREE.Color(0xff0000)},
            };
            uniforms = {
                color: { type:"c", value:new THREE.Color(0x0000ff)},
            };

            var shaderMtl = new THREE.ShaderMaterial({
                uniforms:       uniforms2,
                vertexShader:   document.getElementById('vertexshader2').textContent,   //著色器是一種配色流程
                fragmentShader: document.getElementById('fragmentshader2').textContent, //可交互使用
                transparent: true                                                        //可配對嘗試看看
            });

            var shaderMtl2 = new THREE.ShaderMaterial({
                uniforms:       uniforms,
                vertexShader:   document.getElementById('vertexshader2').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true
            });


            ballmesh = new THREE.Line(ball, shaderMtl);
            ballPoint = new THREE.Points(ball, shaderMtl2);
            scene.add(ballmesh);
            scene.add(ballPoint);

        }




    }

    function animate() {
        control.update();
        console.log(ballmesh);

        requestAnimationFrame( animate );

        render();

    }

    function render() {

        renderer.render( scene, camera );

    }

</script>

</body>
</html>