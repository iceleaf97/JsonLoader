<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>connectome</title>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/dat.gui.min.js"></script>
</head>
<body>

<script type="x-shader/x-vertex" id="vertexshader">

    attribute float alpha;
    attribute vec3 a_color;

    uniform float pointsize;

    varying vec3 v_pos;
    varying float vAlpha;
    varying vec3 v_color;

    void main() {

        vAlpha = alpha;
        v_pos = position;

        v_color = a_color;

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        gl_PointSize = pointsize;

        gl_Position = projectionMatrix * mvPosition;

    }

</script>

<script type="x-shader/x-fragment" id="fragmentshader">

    uniform vec3 color;
    varying vec3 v_pos;
    varying float vAlpha;
    varying vec3 v_color;

    void main() {

        gl_FragColor = vec4( v_color, vAlpha );

    }

</script>

<script>
    // PointCloud with Custom, Dynamic Attribute

    var renderer, scene, camera, cloud, uniforms,mesh,control, cerebrum, params;
    var a_color;
    var colorG = 1;
    var clock = new THREE.Clock();
    var time =0;
    var gui = new dat.GUI();
    var params = {
        colorR: 50,
        colorG: 50,
        colorB: 50
    };






    init();
    animate();

    function init() {

        // renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        // scene
        scene = new THREE.Scene();

        //camera
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set(0,10,30);
        control = new THREE.OrbitControls(camera, renderer.domElement);
        control.target = new THREE.Vector3(0,0,0);
        control.update();

        // point cloud geometry
        var manager = new THREE.LoadingManager();
        manager.onProgress = function (item, loaded, total) {
            console.log(item, loaded, total);
        };
        manager.onLoad = function () {
            console.log('all items loaded');
        };
        manager.onError = function () {
            console.log('there has been an error');
        };

        var jsonLoader = new THREE.JSONLoader(manager);


        jsonLoader.load('models/cerebrum.json', addJsonToScn);
        function addJsonToScn(geometry) {
            var cerebrumGeom = new THREE.BufferGeometry().fromGeometry(geometry);
            console.log(cerebrumGeom.attributes.position.count);
            var numVertices = cerebrumGeom.attributes.position.count;
            var alphas = new Float32Array(numVertices*1);
            for(var i =0; i<numVertices; i++){
                alphas[i] = 0.3;
            }
            a_color = new Float32Array(numVertices*3);
            for(var i=0; i<numVertices * 3; i += 3){
                a_color[i] = params.colorR;
                a_color[i+1] = params.colorG;
                a_color[i+2] = params.colorB;
            }

            cerebrumGeom.addAttribute('a_color', new THREE.BufferAttribute(a_color, 3)); //訊息傳回給vertexShader

            cerebrumGeom.addAttribute('alpha', new THREE.BufferAttribute(alphas, 1));//訊息傳回給vertexShader

            uniforms ={
                color: { type: "c", value: new THREE.Color(0x00ffff)},
                pointsize:{type: "f", value: 1.0 },
            };

            var shaderMtl = new THREE.ShaderMaterial({
               uniforms:        uniforms,
               vertexShader:    document.getElementById('vertexshader').textContent,
               fragmentShader:  document.getElementById('fragmentshader').textContent,
               transparent:     true
            });

            mesh = new THREE.Points(cerebrumGeom, shaderMtl);
            cloud = new THREE.Line(cerebrumGeom, shaderMtl);
            scene.add(cloud);
            scene.add(mesh);
            console.log(mesh.geometry.attributes);
            gui.add(params, 'colorR', 0, 100).onFinishChange(function () {
                params.colorR /= 100;
                var numPoint = mesh.geometry.attributes.position.count;
                for(var i=0; i<numPoint*3; i +=3){
                    a_color[i] = params.colorR;
                }
                mesh.geometry.attributes.a_color.needsUpdate =true;
            });
            gui.add(params, 'colorG', 0, 100).onFinishChange(function () {
                params.colorG /= 100;
                var numPoint = mesh.geometry.attributes.position.count;
                for(var i=0; i<numPoint*3; i +=3){
                    a_color[i+1] = params.colorG;
                }
                mesh.geometry.attributes.a_color.needsUpdate =true;
            });
            gui.add(params, 'colorB', 0, 100).onFinishChange(function () {
                params.colorB /= 100;
                var numPoint = mesh.geometry.attributes.position.count;
                for(var i=0; i<numPoint*3; i +=3){
                    a_color[i+2] = params.colorB;
                }
                mesh.geometry.attributes.a_color.needsUpdate =true;
            });


        }




    }



    function animate() {
        var dt = clock.getDelta();
        dt *= 2;
        time += dt;
        if(cloud && mesh){
     /*       var numPoint = mesh.geometry.attributes.position.count;
            for(var i=0; i<numPoint*3; i +=3){
                a_color[i] =Math.sin(time)+1.2;
                //a_color[i+1] = Math.sin(time)+1.2;
                //a_color[i+2] =Math.sin(time)+1.2;


            }
           mesh.geometry.attributes.a_color.needsUpdate =true;
      */
            mesh.rotation.y += 0.005;
            cloud.rotation.y += 0.005;
        }

        requestAnimationFrame( animate );

        renderer.render( scene, camera );

    }


</script>

</body>
</html>